#include <stdio.h>

int main_p5() {

	// x86, x64
	char a = 1;
	float b = 2;
	double c = 3;

	char* ptr_a = &a;
	float* ptr_b = &b;
	double* ptr_c = &c;

	// sizeof ->  %zd
	printf("%zd %zd %zd \n", sizeof(a), sizeof(b), sizeof(c));

	// 주소 : 4바이트
	printf("%zd %zd %zd \n", sizeof(ptr_a), sizeof(ptr_b), sizeof(ptr_c));

	// 주소 : 4바이트
	printf("%zd %zd %zd \n", sizeof(&a), sizeof(&b), sizeof(&c));

	// 주소를 저장하는 것이라서 4바이트
	printf("%zd %zd %zd \n", sizeof(char*), sizeof(float*), sizeof(double*));

	/*
	// visual studio에서는 위에 Debug x86 으로 되어있기 때문에 4바이트
	2^10 = 1024 byte = KB
	2^10 x 2^10 = 2^20 = MB
	2^10 x 2^10 x 2^10 = 2^30 = GB
	2^10 x 2^10 x 2^10 x 2^2 = 2^32 = 4GB

	64비트가 나오기 전에는 32비트로 표현했다.
	32비트로 최대 표현할 수 있는 게 2^32 = 4기가바이트
	CPU가 처리할 수 있는 용량
	인텔에서 만든 칩셋 이름이 x86 이라는 게 있었는데 그게 32비트

	CPU에 여러 개의 레지스터(기억장치)가 있고, RAM이 있다.
	CPU와 RAM은 주소버스, 컨트롤버스, 데이터버스가 연결되어 있다.
	x86 32비트 체계
	한꺼번에 처리할 수 있는 용량이 4GB
	32비트는 1바이트 = 8비트 => 4바이트체계
	주소값은 표현될 수 있는게 최대 4바이트밖에 안됨
	레지스터가 처리할 수 있는 용량이 4바이트인 것.
	32비트 CPU에서 처리할 수 있는 RAM의 용량은 4GB
	주소의 범위가 4GB밖에 안나온다는 소리
	주소를 요청할 때 1바이트
	=> 하나의 주소 32비트로 하면 표현할 수 있는 게 4바이트
	주소의 번호 1번부터 4GB에 해당되는 번호까지 나온다
	RAM 공간의 주소 4GB밖에 표현 안됨
	32비트체계를 쓰는 CPU에서 8기가 RAM으로 확장을 했다 하더라도
	실제로 처리할 수 있는 메모리의 범위는 4기가 바이트밖에 안된다
	64비트가 나오면서 16기가 32기가 RAM도 사용할 수 있게 된 것이다

	x64로 바꿨을 경우에는 출력이 8로 된다.
	2^64
	8바이트 = 32비트(4바이트) + 32비트(4바이트)
	주소체계가 8바이트 인 것
	64비트 체계는 8바이트

	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	추가설명 다시

	x86
	32bit => 4바이트
	주소를 표현할 수 있는 범위 => 4바이트 = 2^32 이니까 4기가바이트까지 가능

	x64
	64비트 => 32비트 + 32비트 = 4바이트 + 4바이트 => 8바이트
	주소를 표현할 수 있는 범위 => 8바이트 = 2^64 니까 8기가바이트까지 가능
	*/

	return 0;
}