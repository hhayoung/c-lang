#include <stdio.h>


/* 포인터 사용시 주의사항 */
int main_p17() {

    int n = 5;
    double m;

    m = n;
    // double이 int보다 크니까 데이터 손실없이 잘 수행됨.
    // 컨트롤 B -> 빌드 
    // 실행까지 안 시키고 오류가 있는지만 확인할 때는 빌드

    int* ptr_n = &n;
    double* ptr_m = &m;

    // ptr_m = ptr_n;
    // 실행은 되지만 경고가 뜬다.
    // warning C4133: '=': 'int *'과(와) 'double *' 사이의 형식이 호환되지 않습니다.
    // 이렇게 사용하지 X.
    ptr_m = (double*)ptr_n; // casting

    int* ptr;
    int arr1[2][3] = { 3, }; // 원소가 3개짜리인 배열의 배열
    int arr2[3][2] = { 7, }; // 원소가 2개짜리인 배열의 배열

    // ptr 1차원으로 다차원 배열을 모두 접근할 수 있다. 왜?
    // 메모리는 1차원으로 저장하는 구조이기 때문에..
    ptr = &arr1[0][0];
    // ptr = &arr1[0]; //하나만 하면 워닝. 부분배열의 주소

    for (int i = 0; i < 6; i++) {
        printf("%d ", ptr[i]);
    }
    printf("\n");

    ptr = arr1[0];

    // 1차원 != 2차원 배열의 주소형태
    // 일단 문법적으로는 맞지 않으니까 워닝준거같음.
    // 문법상 ptr은 1차원인데, arr1은 2차원
    // ptr = arr1;

    int(*pa)[3]; // 원소가 3개짜리인 배열에 대한 포인터(배열 포인터) **중요한 개념

    // int *pa[3]; // 이거랑은 완전 의미 다른거.
    // 포인터배열. 포인터를 저장하는 배열

    pa = arr1;
    // pa = arr2;
    // 권장되지 않는 표현
    // warning C4048: 배열 첨자가 다릅니다. 'int (*)[3]'과(와) int (*)[2]'

    // warning을 무시하면 안 되는 이유:
    // 원인이 뭔지 모르는 에러가 떴을 때, 해결하는 사람과 해결하지 못하는 사람의 차이는 이런 기초적인 것을 캐치하느냐 못하느냐 차이

    int** ptr2;

    ptr2 = &ptr; // 이중 포인터는 포인터의 주소를 담는다.

    // 이중포인터에 포인터의 주소가 아닌 일반주소를 담았기 때문에 warning 발생 
    // ptr2 = arr2;
    // warning C4047: '=': 'int **'의 간접 참조 수준이 'int (*)[2]'과(와) 다릅니다.

    // 이중 포인터에 * 붙이면 단일 포인터를 의미한다.
    *ptr2 = arr2[0]; // arr2[0]는 int형 메모리 주소이므로 해당 주소를 담을 수 있음.
    // 워닝 안뜨는 이유?
    // : *를 붙임으로써 단일포인터(일반포인터)가 되었기 때문에 일반 주소를 담을 수 있다.

    printf("%d\n", **ptr2);

    // int *ptr3;  // 포인터도 변수이다. 주소를 담는 변수
    // *ptr2 = &ptr3; 
    // warning C4047: '=': 'int *'의 간접 참조 수준이 'int **'과(와) 다릅니다.
    // 단일 포인터라서 포인터의 주소 못 담음.
    // 그냥 ptr2 였으면 담을 수 있다.

    // int *ptr_a;
    // ptr_a = &ptr;
    // warning C4047: '=': 'int *'의 간접 참조 수준이 'int **'과(와) 다릅니다.
    // 단일포인터라서 포인터의 주소를 담을 수가 없음.
    // 포인터의 주소를 담는건 이중포인터기 때문에

    return 0;
}